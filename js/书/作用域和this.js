// JavaScript 引擎进行编译的原理3步
// 1.分词/词法分析
// 将字符组成的字符串分解成有意义的代码块（词法单元）
// 过程中调用的是有状态的规则 就是词法分析  反之分词
// 2.解析/语法分析
// 将词法单元转换成逐级嵌套的抽象语法树AST
// 3.代码执行
// 将AST转换成可执行的代码

// 作用域是一套规则，用于确定在何处以及如何查找变量(标识符)。如果查找的目的是对
// 变量进行赋值，那么就会使用 LHS 查询;如果目的是获取变量的值，就会使用 RHS 查询。 12 | 第1章
  
// 赋值操作符会导致 LHS 查询。=操作符或调用函数时传入参数的操作都会导致关联作用域 的赋值操作。
// JavaScript引擎首先会在代码执行前对其进行编译，在这个过程中，像var a = 2这样的声 明会被分解成两个独立的步骤:
// 1. 首先，var a 在其作用域中声明新变量。这会在最开始的阶段，也就是代码执行前进行。 2. 接下来，a = 2 会查询(LHS 查询)变量 a 并对其进行赋值。
// LHS 和 RHS 查询都会在当前执行作用域中开始，如果有需要(也就是说它们没有找到所 需的标识符)，就会向上级作用域继续查找目标标识符，这样每次上升一级作用域(一层 楼)，最后抵达全局作用域(顶层)，无论找到或没找到都将停止。
// 不成功的 RHS 引用会导致抛出 ReferenceError 异常。不成功的 LHS 引用会导致自动隐式 地创建一个全局变量(非严格模式下)，该变量使用 LHS 引用的目标作为标识符，或者抛 出 ReferenceError 异常(严格模式下)。

// 简单地说，词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写 代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域 不变(大部分情况下是这样的)。
// 无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处 的位置决定。
var z = 10;
function foo(){
  console.log(z)
}
(function(arg){
  var z = 20;
  arg(); //10
})(foo)

作用域链
当代码在一个环境中执行时，会创建变量对象的一个作用域链(scope chain)。作用域链的用途，是 保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所 在环境的变量对象。如果这个环境是函数，则将其活动对象(activation object)作为变量对象。活动对 6 象在最开始时只包含一个变量，即 arguments 对象(这个对象在全局环境中是不存在的)。作用域链中 的下一个变量对象来自包含(外部)环境，而再下一个变量对象则来自下一个包含环境。这样，一直延 续到全局执行环境;全局执行环境的变量对象始终都是作用域链中的最后一个对象


// JS 解析器：
// 1、准备工作：
//   找东西：var 、函数、参数……（预解析的一个表）
  
//     所有的变量预解析的值都是：未定义 
  
//     a = function a(){ alert(2); }
//     （函数名和变量名重名，预解析的时候，会留下函数）
//     a = 3
    
// 2、正式开始干活（逐行解读代码）
//     表达式（动作）：可以修改“表”里面的值
//       = ++ -- += -= *= /= %= 参数 所有的类型转换都是表达式
// */


//闭包就是能够读取其他函数内部变量
//this 实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。
apply()和 call()。这两个方法的用途都是在特定的作 用域中调用函数，实际上等于设置函数体内 this 对象的值
立即执行
//bind(..) 会返回一个硬编码的新函数，不会立即调用

function bind(fn,obj){
  return function(){
    fn.call(obj,arguments)
  }
}
(function(){})()  function(){} 被包含在（）里变成了 表达式
等价
(function(){}())
  
// 判断this 现在我们可以根据优先级来判断函数在某个调用位置应用的是哪条规则。可以按照下面的
// 顺序来进行判断:
// 1. 函数是否在new中调用(new绑定)?如果是的话this绑定的是新创建的对象。
//      var bar = new foo()
// 2. 函数是否通过call、apply(显式绑定)或者硬绑定调用?如果是的话，this绑定的是 指定的对象。
//      var bar = foo.call(obj2)
// 3. 函数是否在某个上下文对象中调用(隐式绑定)?如果是的话，this 绑定的是那个上 下文对象。
//      var bar = obj1.foo()
// 4. 如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到undefined，否则绑定到 全局对象。
//      var bar = foo()
// 如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值
// 在调用时会被忽略，实际应用的是默认绑定规则: